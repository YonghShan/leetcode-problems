### Dynamic Programming

#### Techniques

+ **如何确定可以使用动态规划来解决的？**

  通常我们要从**「有无后效性」**进行入手分析。

  如果对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话，那么这就是一个无后效性的问题，可以考虑使用 DP 解决。==后续变化只取决于当前状态 而与当前状态是如何来的无关。==

  另外一个更加实在的技巧，我们还可以通过 **数据范围** 来猜测是不是可以用 DP 来做。

  ==因为 DP 是一个递推的过程，因此如果数据范围是 $10^5 \sim 10^6$ 的话，可以考虑是不是可以使用一维 DP 来解决；如果数据范围是 $10^2 \sim 10^3$​​ 的话，可以考虑是不是可以使用二维 DP 来做；如果不考虑加入记忆化的DFS，数据范围在 $30$​​​​ 以内。==

  如果题目是需要求得方案数（[[0062]](#[0062] Unique Paths)），可以用DP。==但是如果题目要求枚举具体方案（的细节）则一般不使用DP，因为不满足无后效性（即需要关注状态是如何转移过来的）。要求求得所有的方案，采用回溯算法。但是如果求最佳方案的话，还是能用 DP，只不过在 DP 过程中还需要额外的数据结构（例如数组）来记录路径。== [[0064]](#[0064] Minimum Path Sum)

+ **如何确定本题的状态定义的？**

  说实话，DP 的状态定义很大程度是靠经验去猜的。

  虽然大多数情况都是猜的，但也不是毫无规律，相当一部分题目的状态定义是与**「结尾」**和**「答案」**有所关联的。

+ **如何确定状态转移方程的？**

  通常来说，如果我们的状态定义猜对了，**「状态转移方程」**就是对**「最后一步的分情况讨论」**。

  如果我们有一个对的**「状态定义」**的话，基本上**「状态转移方程」**就是呼之欲出。

  因此一定程度上，**状态转移方程可以反过来验证我们状态定义猜得是否正确**：

  如果猜了一个状态定义，然后发现无法列出涵盖所有情况（不漏）的状态转移方程，多半就是**状态定义猜错了，赶紧换个思路，而不是去死磕状态转移方程**。

+ **对状态转移的要求是什么？**

  状态转移是要做到**「不漏」**还是**「不重不漏」**取决于问题本身：

  + 如果是求最值的话，只需要确保**「不漏」**即可，因为重复不影响结果。

  + 如果是求方案数的话，需要确保**「不重不漏」**。

+ **如何分析动态规划的时间复杂度的？**

  对于动态规划的复杂度/计算量分析，有多少个状态，复杂度/计算量就是多少。

  因此一维 DP 的复杂度通常是线性的，而二维 DP 的复杂度通常是平方的。

+ **如何从二维数组降到一维数组或者其中一维降为常数？**

  + 「一维空间优化」：经过分析，根据状态依赖，调整迭代/循环的方向
  + 「滚动数组」：当计算「某一行」的时候只需要依赖「前一行」时，可以根据==当前的行号是偶数还是奇数来交替使用第 $0$​ 行还是第 $1$​ 行==。因此将其中一维直接改成 $2$​​​，并将任何在该维的 `f[i]` 改成 `f[i&1]` 或者 `f[i%2]` 即可（推荐前者，在不同架构的机器上，运算效率更加稳定）。

  ==**注意：**== 「滚动数组」只会降低「空间复杂度」，不会改变「时间复杂度」。但是，「一维空间优化」同样可能降低「时间复杂度」。

  [[0120]](#[0120] Triangle)

*******

#### Memoization

记忆化搜索，其本质是「递归」（通常是**自顶而上**的解决）。是降低递归复杂度的技巧（==将递归的复杂度降到和DP一致==），可以保证递归的做法在数据范围较大的情况下也可以AC。比如，DFS 通常要求数据范围在30左右，而利用 Memoization 辅助的DFS则可以通过数据范围 $10^2$​​ 的题目。

需要掌握 Memoization 最重要的一个原因是，其是「动态规划」的前置思考。当在不能轻易地猜到「状态定义」以及推导「状态转移方程」时，都可以先使用Memoization求解，再改成DP。==因此，能够使用Memoization求解的前提也是：**问题本身具有无后效性**。==

**如何根据「Memoization」解法写出「Dynamic Programming」解法：**

1. 从 DFS 方法签名出发。分析哪些入参是可变的，将其作为 DP 数组的维度；将返回值作为 DP 数组的存储值。

   $\implies$​ 对应DP的「状态定义」

2. 从 DFS 的主逻辑可以抽象中单个状态的计算方法。

   $\implies$​ 对应DP的「状态转移方程」

到目前为止，我们已经掌握了两种求解「动态规划」问题的方法：

1. 根据经验猜一个「状态定义」，然后根据「状态定义」去推导一个「状态转移方程」。

2. 先写一个「记忆化搜索」解法，再将「记忆化搜索」改写成「动态规划」。

由于「动态规划」的状态定义猜测，是一门很讲求经验的技能。因此对于那些你接触过的模型，我建议你使用第一种方式。

如果遇到一道你从来没接触过的题目时，我建议你先想想「记忆化搜索」该如何实现，然后反推出「动态规划」。

**这里说的想想「记忆化搜索」该如何实现，不需要真正动手实现一个「记忆化搜索」解法，而只需要想清楚，如果使用「记忆化搜索」的话，我的 DFS 函数签名如何设计即可。**

**当搞清楚「记忆化搜索」的函数签名设计之后，「状态定义」部分基本就已经出来了，之后的「状态转移方程」就还是一样的分析方法。**

当然，如果你觉得「记忆化搜索」更好实现的话，大可直接使用「记忆化搜索」求解，不一定需要将其转化为「动态规划」。因为由「记忆化搜索」直接转过来的「动态规划」，两者复杂度是一样的。而且通常「记忆化搜索」的实现难度通常要低很多。

+ **Memoization会比DP快的原因:**

  在 DP 中我们很少会去考虑剪枝，或者很难得到一个很好的剪枝效果。而 DFS 通常会一直往下搜索，得到一个「合法值」，然后利用这个合法值直接减掉一些不必要的递归树。但是 DP 本质是通过 BFS 来得到起始状态到目标状态的拓扑序，无法像 DFS 那样先得到一个合法值。

  另外，以[1575]和[0576]为例，在使用Memoization时，都可以对base case剪枝。DP 解法却更近似于原始未剪枝的Memoizaition。

+ **总结：**

  ==Recursion with Memoization对于大部分的input，其速度都会更快（即使两者复杂度相同），但DP更利于debug，因为可以将DP数组直观地输出，发现哪里出错。==

  「记忆化搜索」和「动态规划」思想上主要区别还是在于「自顶向下」和「自底向上」，实现上则是「递归」和「递推」。

[[1575]](#[1575] Count All Possible Routes)     [[0576]](#[0576] Out of Boundary Paths)

********

#### Applications

##### Pascal's Triangle

[[0118]](#[0118] Pascal's Triangle)     [[0119]](#[0119] Pascal's Triangle II)     [[0120]](#[0120] Triangle)

******

##### 路径问题

[宫水三叶的刷题日记](https://mp.weixin.qq.com/s/flnaRo6VnvkeUQoRDkin9w)

###### 类型一

**特定「起点」，明确且有限的「移动方向」（转移状态），求解所有状态中的最优值。**

*解释：*给定了某个「形状」的数组（三角形或者矩形），使用 **题目给定的起点** 或者 **自己枚举的起点** 出发，再结合题目给定的具体转移规则（往下方/左下方/右下方进行移动）进行转移。

[[0062]](#[0062] Unique Paths)     [[0063]](#[0063] Unique Paths II)     [[0064]](#[0064] Minimum Path Sum)     [[0120]](#[0120] Triangle)     [[0931]](#[0931] Minimum Falling Path Sum)     [[1289]](#[1289] Minimum Falling Path Sum II)     [[1301]]()

###### 类型二

只是告诉了我们移动规则，没有告诉我们具体该如何移动，即**不明确但有限的「移动方向」**。

[[1575]](#[1575] Count All Possible Routes)     [[0576]]()     

###### Template

```java
public int DP(int[][] arr) {
  // Step 1: 定义dp array
  int n = arr.length;
  int[][] f = new int[n][n];

  // Step 2: 初始化dp array，两种情况：
  if (起点固定为arr[0][0]) {
    f[0][0] = arr[0][0]
  } else if (起点为第一行任一元素) {
    for (int i = 0; i < n; i++) f[0][i] = arr[0][i];
  }

  // Step 3: 从第二行进行状态转移
  for (int i = 1; i < n; i++) { // 从f的第二行开始更新
    for (int j = 0; j < n; j++) {
      f[i][j] = Integer.MAX_VALUE;
      int val = arr[i][j];
      // 具体根据移动方向的限制而定：正下方/左下方/右下方/非同列
      ...
    }
  }

  // Step 4: 取结果，两种情况：
  if (终点固定为arr[n-1][n-1]) {
    return f[n-1][n-1];
  } else if (终点为f array最后一行中的最小值) {
    int ans = Integer.MAX_VALUE;
    for (int i = 0; i < n; i++) ans = Math.min(ans, f[n-1][i]);
    return ans;
  }
}
```

******

##### 背包问题

**背包问题是「动态规划」中十分经典的一类问题，背包问题本质上属于组合优化的「 NP完全问题」。**

可以将「 NP完全问题」简单理解为「无法直接求解」的问题。例如「分解质因数」问题，我们无法像四则运算（加减乘除）那样，按照特定的逻辑进行求解。只能通过「穷举」+「验证」的方式进行求解。

既然本质上是一个无法避免「穷举」的问题，自然会联想到「动态规划」，事实上背包问题也同时满足「无后效性」的要求。**这就是为什么「背包问题」会使用「动态规划」来求解的根本原因。**

如果按照常见的「背包问题」的题型来抽象模型的话，「背包问题」大概是对应这样的一类问题：**泛指一类「给定价值与成本」，同时「限定决策规则」，在这样的条件下，如何实现价值最大化的问题。**

******

###### 01背包

指**给定物品价值与体积**（对应了「给定价值与成本」），**在规定容量下**（对应了「限定决策规则」）**如何使得所选物品的总价值最大**。

> 有 $N$​​ 件物品和一个容量是 $C$​​ 的背包。每件物品有且只有一件。第 $i$​​ 件物品的体积是 $v[i]$​​，价值是 $w[i]$​​​。
>
> 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

*e.g.* 

```java
Input: N = 3, C = 5, v = [4,2,3], w = [4,2,3]
Output: 5
Explanation: 不选第一件物品，选择第二件和第三件物品，可使价值最大。
```

如果使用在 [路径问题](#路径问题) 中学到的「技巧解法」来分析：设计一个 DFS 函数对所有的方案进行枚举的话，大概如下：

```java
int dfs (int[] v, int[] w, int i, int c);
```

其中 $v[]$​ 和 $w[]$​ 对应了输入的「物品体积」和「物品价值」，属于不变参数，无须考虑。而 $i$ 和 $c$ 分别代表「当前枚举到哪件物品」和「可使用的背包容量」。返回值（即「状态定义」）则是：**当有物品 $1$、 $2$、... $i$ 可供选择（即仅考虑前 $i$ 件物品）且可使用的背包容量不超过 $c$ 时， 背包的最大价值。**

那么根据变化参数和返回值，可以抽象出 dp 数组：**一个二维数组，其中一维代表「当前枚举到哪件物品」，另外一维「当前可使用的背包容量」，数组内容是「最大价值」。**第一维的取值范围为 $i\in[0,N-1]$​​​​​，第二维的取值范围为 $c \in [0, C]$​​​​​。**因此，$dp[N-1][C]$​​​​​ 即为答案。**

当有了「状态定义」之后，再根据「最后一步」选择来推导「状态转移方程」：**只需要考虑第 $i$​ 件物品如何选择即可：对于第 $i$​ 件物品，我们有「选」和「不选」两种决策。**

+ 「不选」方案的「最大价值」：**「不选」等效于我们只考虑前 $i-1$ 件物品，当前容量为 $c$ 的情况下的最大价值，即 $dp[i-1][c]$。**

+ 「选」方案的「最大价值」：「选」方案必须满足一个前提：「当前剩余的背包容量」$\ge$「物品 $i$ 的体积」。**如果选了第 $i$ 件物品的话，代表消耗了 $v[i]$ 的背包容量，获取了  $w[i]$ 的价值，那么留给前 $i-1$ 件物品的背包容量就只剩 $c-v[i]$，因此最大价值为 $dp[i-1][c-v[i]]+w[i]$。**

在「选」和「不选」之间取最大值，就是「考虑前 $i$​ 件物品，使用容量不超过 $c$​​」的条件下的「背包最大价值」。可得「状态转移方程」为：
$$
dp[i][c]=max(dp[i-1][c],dp[i-1][c-v[i]]+w[i])
$$

+ $dp[N][C+1]$​​​​ 解法

  ```java
  public int maxValue(int N, int C, int[] v, int[] w) {
    // 根据两个维度的取值范围new dp数组
  	int[][] dp = new int[N][C+1];
    // 初始化：先处理「考虑第一件物品」的情况（即dp数组的第一横行的初始值）
    for (int c = 0; c <= C; i++) dp[0][c] = c >= v[0] ? w[0] : 0;
    // 状态转移：再处理「考虑其余物品」的情况
    for (int i = 1; i < N; i++) {
      for (int c = 0; c <= C; c++) {
        // 不选第i件物品
        int ns = dp[i-1][c];
        // 满足前提：选第i件物品
        int s = c >= v[i] ? dp[i-1][c-v[i]] + w[i] : 0;
        dp[i][c] = Math.max(ns, s);
      }
    }
    return dp[N-1][C];
  }
  ```

  针对上面的例子，最终dp数组的内容为：
  $$
  \begin{gathered}
  \small\color{blue}
  \begin{matrix}
  \ \ \ 0\ &1\ &2\ &3\ &4\ &5
  \end{matrix}\\
  \begin{matrix}
  \small\color{blue}0 \\ 
  \small\color{blue}1 \\
  \small\color{blue}2 \\
  \end{matrix}
  \begin{bmatrix}
  [0&0&0&0&4&4] \\
  [0&0&2&2&4&4] \\
  [0&0&2&2&4&\color{red}\bold5\color{black}] \\
  \end{bmatrix}
  \end{gathered}
  $$

  + *Time Complexity:* $\mathcal{O}(N*C)$​​

  + *Space Complexity:* $\mathcal{O}(N*C)$​

+ 「滚动数组」：$dp[2][C+1]$​​

  根据「转移方程」，计算第 $i$ 行格子只需要第 $i-1$ 行中的某些值。也就是计算「某一行」的时候只需要依赖「前一行」。因此可以用一个只有两行的数组来存储中间结果，根据当前计算的行号是偶数还是奇数来交替使用第 0 行和第 1 行。

  ```java
  public int maxValue(int N, int C, int[] v, int[] w) {
  	int[][] dp = new int[2][C+1];
    // 初始化：先处理「考虑第一件物品」的情况（即dp数组的第一横行的初始值）
    for (int c = 0; c <= C; i++) dp[0][c] = c >= v[0] ? w[0] : 0;
    // 状态转移：再处理「考虑其余物品」的情况
    for (int i = 1; i < N; i++) {
      for (int c = 0; c <= C; c++) {
        // 不选第i件物品
        int ns = dp[(i-1)&1][c];
        // 满足前提：选第i件物品
        int s = c >= v[i] ? dp[(i-1)&1][c-v[i]] + w[i] : 0;
        dp[i&1][c] = Math.max(ns, s);
      }
    }
    return dp[(N-1)&1][C];
  }
  ```

  + *Time Complexity:* $\mathcal{O}(N*C)$​

  + *Space Complexity:* $\mathcal{O}(C)$​

+ 「一维空间优化」：$dp[C+1]$​​     **==重点==**

  不难发现当求解第 $i$ 行格子的值时，不仅是只依赖第 $i-1$ 行，还明确只依赖第 $i-1$ 行的第 $c$ 个格子和第 $c-v[i]$ 个格子（也就是对应着第 $i$ 个物品「不选」和「选」的两种情况）。换句话说，只依赖于「上一个格子的位置」以及「上一个格子的左边位置」。

  <img src="/Users/shanyonghao/IdeaProjects/LeetCodeProblems/Notes_img/背包问题_1.jpg" style="zoom:50%;" />

  因此，只要将求解第 $i$​ 行格子的顺序「从 $0$​ 到 $c$​」改为「从 $c$​ 到 $0$​」，就可以将原本 2 行的二维数组压缩到一行（转换为一维数组）。

  故，「01背包」在采用「一维空间优化」解法时，「状态转移方程」修改为：
  $$
  dp[c]=max(dp[c], dp[c-v[i]]+w[i])
  $$
  同时，容量维度 $c$ 的遍历顺序为**==从大到小==**。

  **这样做的空间复杂度和「滚动数组」优化的空间复杂度是一样的。但仍然具有意义，而且这样的「一维空间」优化，是求解其他背包问题的基础，需要重点掌握。**

  ```java
  public int maxValue(int N, int C, int[] v, int[] w) {
  	int[] dp = new int[C+1];
    
    for (int i = 0; i < N; i++) {
      for (int c = C; c >= v[i]; c--) {
        // 不选第i件物品
        int ns = dp[c];
        // 选第i件物品
        int s = dp[c-v[i]] + w[i];
        dp[c] = Math.max(ns, s);
      }
    }
    return dp[C];
  }
  ```

  + *Time Complexity:* $\mathcal{O}(N*C)$​

  + *Space Complexity:* $\mathcal{O}(C)$​​

**总结：** ==在众多背包问题中，「01背包」是最为核心的，且「01背包」的「一维空间优化」解法是几乎所有背包问题的基础，重点掌握。==

************

###### 完全背包

在 0-1 背包问题的基础上，增加了每件物品可以选择多次的特点（在容量允许的情况下）。

> 有 $N$ 种物品和一个容量为 $C$ 的背包，每种物品都有无限件。第 $i$ 件物品的体积是 $v[i]$，价值是 $w[i]$。
>
> 求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

*e.g.*

```java
Input: N = 2, C = 5, v = [1, 2], w = [1, 2]
Output: 5
Explanation: 选第一件物品 1， 再选两件物品 2，可使价值最大。
```

直接将 01 背包的「状态定义」拿过来用：**$dp[i][j]$​ 代表考虑前 $i$​ 件物品，放入一个容量为 $c$​ 的背包可以获得的最大价值。**

由于每件物品可以被选择多次，因此对于某个 $dp[i][c]$​ 而言，其值应该为以下所有可能方案中的最大值：

- 选择 0 件物品 $i$​​ 的最大价值，即 $dp[i-1][c]$​

- 选择 1 件物品 $i$​ 的最大价值，即 $dp[i-1][c-v[i]]+w[i]$​

- 选择 2 件物品 $i$​ 的最大价值，即 $dp[i-1][c-2*v[i]]+2*w[i]$​

  $\dots$

- 选择 k 件物品 $i$​ 的最大价值，即 $dp[i-1][c-k*v[i]]+k*w[i]$​

由此，可以得出「状态转移方程」为：
$$
dp[i][c] = max(dp[i-1][c], dp[i-1][c-k*v[i]]+k*w[i]), 0 < k*v[i]\le c
$$
**从「数学」的角度进一步简化上面的「状态转移方程」：**<a name="「完全背包」一维方程推导"></a>

1. 展开「完全背包」原本的「状态转移方程」：
   $$
   \begin{aligned}
   dp[i][c] &= max(dp[i-1][c], \underline{dp[i-1][c-k*v[i]]+k*w[i]}),0 <k*v[i]\le c\\
   &= max(dp[i-1][c], \underline{\color{blue}{dp[i-1][c-v[i]]+\bold{w[i]}},\color{green}{dp[i-1][c-2*v[i]]+\bold{2*w[i]}}\color{black}{+\dots} + \color{orange}{dp[i-1][c-k*v[i]]+\bold{k*w[i]}}}),0<k*v[i]\le c
   \end{aligned}
   $$

2. 同理，$dp[i][c-v[i]]$​​ 的展开式为：
   $$
   dp[i][c-v[i]] = max(\underline{\color{blue}{dp[i-1][c-v[i]]},\color{green}{dp[i-1][c-2*v[i]]+\bold{w[i]}}\color{black}{+\dots} + \color{orange}{dp[i-1][c-k*v[i]]+\bold{(k-1)*w[i]}}}),0<k*v[i]\le c
   $$

3. 比较发现，上述两式的划线部分具有“等差”特性，总是相差 $w[i]$，因此
   $$
   dp[i][c] = max(dp[i-1][c],dp[i][c-v[i]]+w[i])
   $$

代码部分，分别提供对应两版「状态转移方程」的不同解法：

==**只是已经推导到第二版「状态转移方程」后，完全可以直接写「一维空间优化」解法**==

+ $dp[N][C+1]$​ 解法：

  ```java
  public int maxValue(int N, int C, int[] v, int[] w) {
    int[][] dp = new int[N][C+1];
    
    // 先预处理「第一件物品」
    for (int c = 0; c <= C; c++) {
      // 显然当只有一件物品，在容量允许的情况下，能选多少件就选多少件
      int maxK = j / v[0];
      dp[0][c] = maxK * w[0];
    }
    
    // 再处理「剩余物品」
    for (int i = 1; i < N; i++) {
      for (int c = 0; c <= C; c++) {
        // 「不选」：选择 0 件物品 i
        int ns = dp[i-1][c];
        // 「选」：
        int s = 0;
        for (int k = 0; k * v[i] <= c; k++) { // 当v[i] = 1时，k可取到c
          s = Math.max(s, dp[i-1][c-k*v[i]] + k*w[i]); 
        }
        dp[i][c] = Math.max(ns, s);
      }
    }
    
    return dp[N-1][C];
  }
  ```

  + *Time Complexity:* $\mathcal{}(N*C*C)$​​​

  + *Space Complexity:* $\mathcal{O}(N*C)$​​

  ```java
  public int maxValue(int N, int C, int[] v, int[] w) {
    int[][] dp = new int[N][C+1];
    
    // 先预处理「第一件物品」
    for (int c = 0; c <= C; c++) {
      // 显然当只有一件物品，在容量允许的情况下，能选多少件就选多少件
      int maxK = j / v[0];
      dp[0][c] = maxK * w[0];
    }
    
    // 再处理「剩余物品」
    for (int i = 1; i < N; i++) {
      for (int c = 0; c <= C; c++) {
        // 「不选」：选择 0 件物品 i
        int ns = dp[i-1][c];
        // 「选」：
        int s = c >= v[i] ? dp[i][c-v[i]] + w[i] : 0;
        dp[i][c] = Math.max(ns, s);
      }
    }
    
    return dp[N-1][C];
  }
  ```

  + *Time Complexity:* $\mathcal{O}(N*C)$​​​​

  + *Space Complexity:* $\mathcal{O}(N*C)$​

+ 「滚动数组」：

  ```java
  public int maxValue(int N, int C, int[] v, int[] w) {
    int[][] dp = new int[2][C+1];
    
    // 先预处理「第一件物品」
    for (int c = 0; c <= C; c++) {
      // 显然当只有一件物品，在容量允许的情况下，能选多少件就选多少件
      int maxK = j / v[0];
      dp[0][c] = maxK * w[0];
    }
    
    // 再处理「剩余物品」
    for (int i = 1; i < N; i++) {
      for (int c = 0; c <= C; c++) {
        // 「不选」：选择 0 件物品 i
        int ns = dp[(i-1)&1][c];
        // 「选」：
        int s = 0;
        for (int k = 0; k * v[i] <= c; k++) { // 当v[i] = 1时，k可取到c
          s = Math.max(s, dp[(i-1)&1][c-k*v[i]] + k*w[i]); 
        }
        dp[i&1][c] = Math.max(ns, s);
      }
    }
    
    return dp[(N-1)&1][C];
  }
  ```

  + *Time Complexity:* $\mathcal{O}(N*C*C)$​​​

  + *Space Complexity:* $\mathcal{O}(C)$​​​

  ```java
  public int maxValue(int N, int C, int[] v, int[] w) {
    int[][] dp = new int[2][C+1];
    
    // 先预处理「第一件物品」
    for (int c = 0; c <= C; c++) {
      // 显然当只有一件物品，在容量允许的情况下，能选多少件就选多少件
      int maxK = j / v[0];
      dp[0][c] = maxK * w[0];
    }
    
    // 再处理「剩余物品」
    for (int i = 1; i < N; i++) {
      for (int c = 0; c <= C; c++) {
        // 「不选」：选择 0 件物品 i
        int ns = dp[(i-1)&1][c];
        // 「选」：
        int s = c >= v[i] ? dp[i&1][c-v[i]] + w[i] : 0;
        dp[i&1][c] = Math.max(ns, s);
      }
    }
    
    return dp[(N-1)&1][C];
  }
  ```

  + *Time Complexity:* $\mathcal{O}(N*C)$​​​

  + *Space Complexity:* $\mathcal{O}(C)$​​

+ 「一维空间优化」：**==重点==**

  虽然「完全背包」问题有两个版本的「状态转移方程」，但是对于「一维空间优化」解法，选择第二个化简后的「状态转移方程」进行 $i$ 维度的消除：
  $$
  dp[c] = max(dp[c], dp[c-v[i]]+w[i])
  $$

  ```java
  public int maxValue(int N, int C, int[] v, int[] w) {
    int[] dp = new int[C+1];
    
    for (int i = 0; i < N; i++) {
      for (int c = v[i]; c <= C; c++) {  // 与「01背包」不同，依旧是从小到大遍历
        // 「不选」：选择 0 件物品 i
        int ns = dp[c];
        // 「选」：
        int s = dp[c-v[i]] + w[i];
        dp[c] = Math.max(ns, s);
      }
    }
   
    return dp[C];
  }
  ```


  + *Time Complexity:* $\mathcal{O}(N*C)$​​
  + *Space Complexity:* $\mathcal{O}(C)$​​​

==**总结：**==

- 0-1 背包问题的状态转换方程是：

$$
dp[i][c] = max(dp[i-1][c],dp[i-1][c-v[i]]+w[i])
$$

**由于计算 $dp[i][c]$ 的时候，依赖于 $dp[i-1][c-v[i]]$。**

**因此，在改为「一维空间优化」时，需要确保 $dp[c-v[i]]$ 存储的是上一行的值，即确保 $dp[c-v[i]]$ 还没有被更新，所以遍历方向是从大到小。**

- 完全背包问题的状态转移方程是：

$$
dp[i][c]=max(dp[i-1][c],dp[i][c-v[i]]+w[i])
$$

**由于计算 $dp[i][c]$ 的时候，依赖于 $dp[i][c-v[i]]$。**

**因此，在改为「一维空间优化」时，需要确保 $dp[i][c-v[i]]$ 存储的是当前行的值，即确保 $dp[c-v[i]]$​ 已经被更新，所以遍历方向是从小到大。**

**形式上，只需要将「 01 背包」问题的「一维空间优化」解法中的「容量维度」遍历方向从「从大到小」改为「从小到大」就可以解决完全背包问题。**

**但本质是因为两者进行状态转移时依赖了不同的格子：**

- **「01 背包」依赖的是「上一行正上方的格子」和「上一行左边的格子」。**
- **「完全背包」依赖的是「上一行正上方的格子」和「本行左边的格子」。**

********

###### 多重背包

在 0-1 背包问题的基础上，增加了每件物品可以选择「有限次数」的特点（在容量允许的情况下）。

> 有 $N$ 种物品和一个容量为 $C$ 的背包，每种物品**「数量有限」**。第 $i$ 件物品的体积是 $v[i]$，价值是 $w[i]$，数量为 $s[i]$。
>
> 问选择哪些物品，每件物品选择多少件，可使得总价值最大。

*e.g.*

```java
Input: N = 2, C = 5, v = [1, 2], w = [1, 2], s = [2, 1]
Output: 4
Explanation: 选两件物品 1，再选一件物品 2，可使价值最大
```

**几乎所有的「背包问题」都是基于「01 背包」演变而来。**套用「01 背包」的「状态定义」来进行分析：**$dp[i][c]$ 代表考虑前 $i$ 件物品，且所选物品总体积不超过 $c$ 时获得的最大价值。**

由于每件物品可以被选择「有限次」，因此对于某个 $i$ 而言，其值应该为以下所有可能方案中的最大值：

- 选择 $0$ 件物品 $i$ 的最大价值，即 $dp[i][c]=dp[i-1][c]$

- 选择 $1$ 件物品 $i$ 的最大价值，即 $dp[i][c]=dp[i-1][c-v[i]]+w[i]$

- 选择 $2$ 件物品 $i$ 的最大价值，即 $dp[i][c]=dp[i-1][c-2*v[i]]+2*w[i]$

  $\dots$

- 选择 $s[i]$ 件物品 $i$ 的最大价值，即 $dp[i][c]=dp[i-1][c-s[i]*v[i]]+s[i]*w[i]$

由此可以得出「状态转移方程」为：
$$
dp[i][c]=max(dp[i-1][c], dp[i-1][c-k*v[i]]+k*w[i]),\ 0< k\le s[i],\ 0< k*v[i]\le c
$$
可以发现其状态转移方程与「完全背包」完全一致，只是多了 $0<k\le s[i]$ 的条件。毕竟「完全背包」不限制物品数量，「多重背包」限制物品数量。

+ $dp[N][C+1]$ 解法：==和「完全背包」一样，除了最内层循环 $k$ 多了个判断条件：$k\le s[i]$==

  ```java
  public int maxValue(int N, int C, int[] s, int[] v, int[] w) {
    int[][] dp = new int[N][C+1];
    
    // 先处理第一件物品：
    for (int c = 0; c <= C; c++) {
      int maxK = Math.min(s[0], c / v[0]);
      dp[0][c] = maxK * w[0];
    }
    
    // 处理剩余物品
    for (int i = 1; i < N; i++) {
      for (int c = 0; c <= C; c++) {
        // 「不选」：
        int ns = dp[i-1][c];
        // 「选」：
        int s = 0;
        for (int k = 1; k <= s[i] && k * v[i] <= c; k++) 
          s = Math.max(s, dp[i-1][c-k*v[i]]+k*w[i]);
        dp[i][c] = Math.max(ns, s);
      }
    }
    
    return dp[N-1][C];
  }
  ```

  + *Time Complexity:* 共有三层循环的运算量，即 $N*C*S$，其中 $N*S=\sum_{i=0}^{N-1}s[i]$。故整体复杂度为 $\mathcal{O}(\sum_{i=0}^{N-1}s[i]*C)$
  + *Space Complexity:* $\mathcal{O}(N*C)$

+ 「滚动数组」解法：

  通过观察「状态转移方程」可以发现，在更新某个 $dp[i][c]$ 时，只依赖于 $dp[i-1][]$。因此可以像「01背包」那样使用「滚动数组」的方式将空间优化到 $\mathcal{O}(C)$。

  ```java
  public int maxValue(int N, int C, int[] s, int[] v, int[] w) {
    int[][] dp = new int[2][C+1];
    
    // 先处理第一件物品：
    for (int c = 0; c <= C; c++) {
      int maxK = Math.min(s[0], c / v[0]);
      dp[0][c] = maxK * w[0];
    }
    
    // 处理剩余物品
    for (int i = 1; i < N; i++) {
      for (int c = 0; c <= C; c++) {
        // 「不选」：
        int ns = dp[(i-1)&1][c];
        // 「选」：
        int s = 0;
        for (int k = 1; k <= s[i] && k * v[i] <= c; k++) 
          s = Math.max(s, dp[(i-1)&1][c-k*v[i]]+k*w[i]);
        dp[i&1][c] = Math.max(ns, s);
      }
    }
    
    return dp[(N-1)&1][C];
  }
  ```

  + *Time Complexity:* $\mathcal{O}(\sum_{i=0}^{N-1}s[i]*C)$
  + *Space Complexity:* $\mathcal{O}(N*C)$

+ 「一维空间优化」解法：

  **「多重背包」可以通过「一维空间优化」优化空间，但是不能降低时间复杂度。**因为当像「完全背包」那样只保留「容量维度」，并且「从小到大」遍历容量的话，在转移 $f[c]$ 时是无法直接知道所依赖的 $f[c-v[i]]$ 到底使用了多少件物品 $i$ 的。

  这个问题在「完全背包」里面无须关心，因为每件物品可以被选择无限次，而在「多重背包」则是不能忽略，否则可能会违背物品件数有限的条件。

  因此，「多重背包」问题的「一维空间优化」并不能像「完全背包」那样使复杂度降低。

  ```java
  public int maxValue(int N, int C, int[] s, int[] v, int[] w) {
    int[] dp = new int[C+1];
    
    for (int i = 0; i < N; i++) {
      for (int c = C; c >= v[i]; c--) {  // c「从大到小」
        for (int k = 1; k <= s[i] && k * v[i] <= c; k++) 
          dp[c] = Math.max(dp[c, dp[c-k*v[i]]+k*w[i]);
      }
    }
    
    return dp[(N-1)&1][C];
  }
  ```

  + *Time Complexity:* $\mathcal{O}(\sum_{i=0}^{N-1}s[i]*C)$
  + *Space Complexity:* $\mathcal{O}(C)$

==**与其他背包的内在关系：**==

+ **只有「完全背包」的「一维空间优化」是存在数学意义上的优化（能够有效降低算法时间复杂度）。**

  **「01 背包」和「多重背包」的「一维空间优化」其实只是基于「朴素二维」解法做单纯的「滚动」操作而已（利用状态之间的依赖关系，配合遍历顺序，使得不再需要参与转移的空间能够被重新利用）。**

  因此，一定程度上，可以将「多重背包」看做是一种特殊的「01 背包」。

+ 转换为「01背包」：

  对「01 背包」中具有相同的价值 & 成本的物品进行计数，就成了对应物品的「限制件数」，「01 背包」也就转换成了「多重背包」。

  同理，将「多重背包」的多件物品进行「扁平化展开」，就转换成了「01 背包」。

  扁平化需要遍历所有物品，枚举每件物品的数量，将其添加到一个新的物品列表里。再套用「01 背包」的解决方案。

  ```java
  public int maxValue(int N, int C, int[] s, int[] v, int[] w) {
    // 将多件数量的同一物品进行「扁平化」展开，以 [v, w] 形式存储
    List<int[]> arr = new ArrayList<>(); 
    for (int i = 0; i < N; i++) {
      int cnt = s[i];
      while (cnt-- > 0) 
        arr.add(new int[]{v[i], w[i]});
    }
  
    // 使用「01背包」进行求解
    int[] dp = new int[C + 1];
    for (int i = 0; i < arr.size(); i++) {
      int vi = arr.get(i)[0], wi = arr.get(i)[1];
      for (int j = C; j >= vi; j--) {
        dp[j] = Math.max(dp[j], dp[j - vi] + wi);   
      }
    }
    return dp[C];
  }
  ```

  - *Time Complexity:* 扁平化的计算量取决于最终能展开成多少个物品（$\sum_{i=0}^{N-1}s[i]$）。共有 $\mathcal{O}(\sum_{i=0}^{N-1}s[i]*C)$ 个状态需要被转移，因此整体复杂度为 $\mathcal{O}(\sum_{i=0}^{N-1}s[i]*C)$
  - *Space Complexity:* $\mathcal{O}(\sum_{i=0}^{N-1}s[i]+C)$

  **可以发现，转换成「01 背包」之后，时间复杂度并没有发生变化。因此将「多重背包」简单的转换成「01 背包」并不能带来效率的提升。甚至说转换成「01 背包」之后效率上还要稍微差一点，因为额外增大了“常数”。**

  扁平化操作并没有使得物品“变少”，仍然需要枚举所有的“组合”，从中选择最优，组合的数量没有发生变化，还额外增加了扁平化的操作。—— 这是将「多重背包」转换成「01 背包」进行求解没有“实际意义”（但可以帮助理解两者之间的联系）的原因。

==**总结：**== 无论是「朴素二维」、「滚动数组」、「一维优化」还是「扁平化」都不能优化「多重背包」问题的时间复杂度。在各维度数量级同阶的情况下，时间复杂度是 $\mathcal{O}(n^3)$ 的。这意味着只能解决 $10^2$ 数量级的「多重背包」问题。

==**「多重背包」的优化方法：**==

+ 「二进制优化」：使得能解决的多重背包问题数量级从 $n^2$ 上升为 $n^3$。$\color{red}\star\star\star$

  **所谓的「二进制优化」其实是指，如何将一个「多重背包」问题彻底转化为「01背包」问题，同时降低其复杂度。**

  在「扁平化展开」的基础上，如果能将重复物品的数量变小，那么这样的「扁平化」就是有意义的。

  Linux 的文件权限最高是 7，代表拥有读、写、执行的权限，但其实是采用了 3 个数来对应 8 种情况的“压缩”方法 —— 7 是对应了 1、2、4 三个数字的，也就是 `r:1`、`w:2`、`x:4` ，三种权限的组合共有 8 种可能性。

  「二进制优化」就是借鉴这样的思路：**将原本数量为 $s[i]$ 的物品拆分成 $\lceil{log(s[i])}\rceil$ 件，从而降低算法复杂度。**

  7 可以用 `1、2、4` 来代替，10 可以使用 `1、2、4、3` 来代替。不用 `1、2、4、6` 或者 `1、2、4、8`，是因为 `1、2、4、6` 可以表达的范围是 0~13，而 `1、2、4、8` 可以表达的范围是 0~15，而要求的是表达 10，大于 10 的范围是不能被选择的。所以可以在 `1、2、4` （表达的范围是 0~7）的基础上，增加一个数 3（由 10 - 7 而来），这样就能满足需要表达的范围 0~10。

  *e.g.* 

  + 原输入：
    $$
    \begin{aligned}
    v&=[1,2,\color{red}{3}\color{black},4,5] \\
    w&=[1,3,\color{red}2\color{black},5,4] \\
    s&=[1,1,\color{red}10\color{black},1,1]
    \end{aligned}
    $$

  + 「扁平化展开」$\rightarrow$ 「二进制优化」：
    $$
    \begin{aligned}
    v_{扁平化}&=[1,2,\color{orange}\underline{3},\color{blue}\underline{3,3},\color{green}\underline{3,3,3,3},\color{pink}\underline{3,3,3}\color{black},4,5] \\
    w_{扁平化}&=[1,3,\color{orange}\underline2,\color{blue}\underline{2,2},\color{green}\underline{2,2,2,2},\color{pink}\underline{2,2,2}\color{black},5,4] \\
    s_{扁平化}&=[1,1,\color{orange}\underline{1},\color{blue}\underline{1,1},\color{green}\underline{1,1,1,1},\color{pink}\underline{1,1,1}\color{black},1,1] \\
    \implies v_{二进制}&=[1,2,\color{orange}3,\ \ \color{blue}6,\quad\ \ \color{green}12,\quad\quad\ \color{pink}9\quad\color{black},4,5] \\
    w_{二进制}&=[1,3,\color{orange}2,\ \ \color{blue}4,\quad\quad\color{green}8,\quad\quad\ \color{pink}6\quad\color{black},5,4] \\
    s_{二进制}&=[1,1,\color{orange}1,\ \ \color{blue}1,\quad\quad\color{green}1,\quad\quad\ \color{pink}1\quad\color{black},1,1] 
    \end{aligned}
    $$

  *解释：* 

  |        $s$        |                         $s_{二进制}$                         |
  | :---------------: | :----------------------------------------------------------: |
  | 选 $0$ 件 $s[2]$  |                             不选                             |
  | 选 $1$ 件 $s[2]$  |                      选 $s_{二进制}[2]$                      |
  | 选 $2$ 件 $s[2]$  |                      选 $s_{二进制}[3]$                      |
  | 选 $3$ 件 $s[2]$  |                      选 $s_{二进制}[5]$                      |
  | 选 $4$ 件 $s[2]$  |                      选 $s_{二进制}[4]$                      |
  | 选 $5$ 件 $s[2]$  |               选 $s_{二进制}[2],s_{二进制}[4]$               |
  | 选 $6$ 件 $s[2]$  |               选 $s_{二进制}[3],s_{二进制}[4]$               |
  | 选 $7$ 件 $s[2]$  |        选 $s_{二进制}[2],s_{二进制}[3],s_{二进制}[4]$        |
  | 选 $8$ 件 $s[2]$  |        选 $s_{二进制}[2],s_{二进制}[4],s_{二进制}[5]$        |
  | 选 $9$ 件 $s[2]$  |        选 $s_{二进制}[3],s_{二进制}[4],s_{二进制}[5]$        |
  | 选 $10$ 件 $s[2]$ | 选 $s_{二进制}[2],s_{二进制}[3],s_{二进制}[4],s_{二进制}[5]$ |

  ```java
  public int maxValue(int N, int C, int[] s, int[] v, int[] w) {
    List<Integer> worth = new ArrayList<>();
    List<Integer> volume = new ArrayList<>();
  
    // 希望每件(重复的)物品都进行扁平化，所以遍历所有的物品
    for (int i = 0; i < N; i++) {
      // 获取每件物品的出现次数
      int val = s[i];
      // 进行扁平化：如果一件物品规定的使用次数为 7 次，我们将其扁平化为三件物品：1*重量&1*价值、2*重量&2*价值、4*重量&4*价值
      for (int k = 1; k <= val; k *= 2) { 
        val -= k;
        worth.add(w[i] * k);
        volume.add(v[i] * k);
      }
      if (val > 0) {
        worth.add(w[i] * val);
        volume.add(v[i] * val);
      }
    }
  
    // 使用「01背包」解决：
    int[] dp = new int[C + 1];
    for (int i = 0; i < worth.size(); i++) {
      for (int j = C; j >= volume.get(i); j--) {
        dp[j] = Math.max(dp[j], dp[j - volume.get(i)] + worth.get(i));
      }
    }
    return dp[C];
  }
  ```

  + *Time Complexity:* $\mathcal{O}(\sum_{i=0}^{n-1}\lceil{logs}[i]\rceil*C)$
  + *Space Complexity:* $\mathcal{O}(\sum_{i=0}^{n-1}\lceil{logs}[i]\rceil+C)$

+ 「单调队列优化」$\color{red}\star\star\star\star\star$

  **与对「物品」做拆分的「二进制优化」不同，「单调队列优化」是对「状态」做拆分操作。**

  首先，还是使用一维空间优化的定义：**$f[c]$ 代表容量不超过 $c$ 时的最大价值。**当遍历完所有的物品后，$f[C]$ 就是答案。

  在朴素的「多重背包」解决方案中，当在处理某一个物品从 $f[0]$ 到 $f[C]$ 的状态时，每次都是通过遍历当前容量 $x$ 能够装多少件该物品，然后从所有遍历结果中取最优（根据题目，取最大或最小）。==**但事实上，转移只会发生在「对当前物品体积取余相同」的状态之间。**==

  *e.g.* 假设当前处理到的物品**体积为 $2$** ，**数量为 $3$** ，而**背包容量为 $10$**，那么从 $f[0]$ 转移到 $f[10]$ 时，存在如下规律：

  - $f[10]$ 只能由 $f[8],f[6],f[4]$ 转移而来

  - $f[9]$ 只能由 $f[7],f[5],f[3]$ 转移而来

    $\dots$

  - $f[5]$ 只能由 $f[3],f[1]$ 转移而来

  - $f[4]$ 只能由 $f[2],f[0]$ 转移而来

  - $f[3]$ 只能由 $f[1]$ 转移而来

  - $f[2]$ 只能由 $f[0]$ 转移而来

  ==**即某个状态 $f[c]$ 只能由对 $v$ 取余和 $c\bmod v$（$v$ 为当前物品体积，$c$ 为当前背包容量）相同，比 $c$ 小，数量不超过「物品个数」的状态值所更新。**== *（10/8/6/4 对 2 取余结果相同，都为0，8/6/4 均比 10 小，8/6/4 共三个，不超过物品个数；5/3 对 2 取余结果相同，都为1，3 比 5 小，3 共一个，不超过物品个数...）*

  因此这其实是一个「滑动窗口求最值」问题（窗口的大小最多不超过「物品个数」；最值指根据题意取窗口内元素的最大/小值）。

  **如果能够在转移 $f[c]$ 时，以 $\mathcal{O}(1)$ 或者均摊 $\mathcal{O}(1)$ 的复杂度从「能够参与转移的状态」（即窗口）中找到最大值，就能省掉朴素「多重背包」解决方案中最内层的“决策”循环，从而将整体复杂度降低到 $\mathcal{O}(N*C)$。**

  具体地，定义一个数组 $g$ ，用来记录上一个物品转移后的结果（即 $f[]$）；定义一个数组 $q$ 来作为滑动窗口，用来存放本次物品转移时所用到的所有 $c$ 。

  由于希望在 $\mathcal{O}(1)$ 复杂度内取得「能够参与转移的状态」中的最大值，自然期望能够在滑动窗口的头部或者尾部直接取得目标值来更新 。为此，需要维持「窗口内元素单调」和「特定的窗口大小」。==这里滑动窗口内元素单调并不是指 $c$ 按照大小排序，而是按照每个 $c$ 所对应的 $f[c]$ 的大小来排序 $c$ 。==例如：$f[1]=4,f[2]=1,f[3]=5$，则窗口的内容为 $[3,1,2]$。

  ```java
  public int maxValue(int N, int C, int[] s, int[] v, int[] w) {
    int[] f = new int[C + 1];
    int[] g = new int[C + 1]; // 辅助数组，记录上一个物品转移完dp数组f的结果
    int[] q = new int[C + 1]; // 滑动窗口，记录c，c的排序由其对应的f[c]的值决定，单调（递减）
  
    // 枚举物品
    for (int i = 0; i < N; i++) {
      int vi = v[i];
      int wi = w[i];
      int si = s[i];
  
      // 将上次算的结果存入辅助数组中
      g = f.clone();
  
      // 枚举余数rem：c mod vi < vi ==>> rem的取值范围为[0, vi)
      for (int rem = 0; rem < vi; rem++) {
        // 初始化窗口，head 和 tail 分别指向窗口队列的头部和尾部
        int head = 0, tail = -1;
        // 枚举同一余数情况下，c有多少种方案。
        // 例如余数为 1 的情况下，c可以为1、vi + 1、2 * vi + 1、3 * vi + 1 ...
        // 结合上述例子（vi=2, si=3, wi=3, C=10），rem为1时，c可为1，3，5，7，9
        for (int c = rem; c <= C; c += vi) {
          // 如果不选当前物品的话，则对于此时的容量c，其最优值为上一个物品该容量时的转移结果，即g[c]
          f[c] = g[c];
          // 如果选择当前物品，则对于此时的容量c，其更新的依据为滑动窗口内的元素
          // 首先，需要将不在窗口范围内的c的取值弹出
          if (head <= tail && q[head] < c - si * vi) head++;
          // 接着，如果队列中仍存在元素，直接使用队首元素来更新
          if (head <= tail) f[c] = Math.max(f[c], g[q[head]] + (c - q[head]) / vi * wi);
          // 增加判断：如果当前值比队尾值更优时，队尾元素没有存在必要，队尾出队
          while (head <= tail && g[q[tail]] - (q[tail] - rem) / vi * wi <= g[c] - (c - rem) / vi * wi) tail--;
          // 最后，将新下标c入队尾，从而保证窗口内的元素一直被更新且保持单减（队首元素最优） 
          q[++tail] = c;
        }
      }
    }
    return f[C];
  }
  ```

  + *Time Complexity:* $\mathcal{O}(N*C)$
  + *Space Complexity:* $\mathcal{O}(C)$

  *解释：* 

  首先，对于任一 $rem$ 都会有一个滑动窗口；接着，同一余数情况下，具体到某一个 $c$ 时，窗口的内容都需要更新。
  结合上述例子（$vi=2,si=3,wi=3,C=10$），$rem$ 为 $1$ 时：

  + $c = 1$：此时窗口内无值，即 $head=0,tail=-1$
  + $c = 3$：此时 $head=tail=0$，窗口 $q$ 内 $q[head]=q[0]=1 > c-si*vi=3-2*3=-3$，故不需要更新 $head$，$f[3]$ 的转移会用到 $f[1]$：$f[3]=max(f[3], g[1]+(3-1)/2*3)$；假设 $g[1]-(1-1)/2*3<g[3]-(3-1)/2*3$，故窗口内 $f[1]$ 没必要继续保留，$tail$ 更新为 $-1$；最终，将 $c=3$ 入窗口 $q$，$tail$ 更新为 $0$
  + $c = 5$：此时$head=tail=0$，窗口 $q$ 内 $q[head] = q[0] = 3$，故 $f[5]$ 的转移会用到 $f[3]$：$f[5]=max(f[5], g[3]+(5-3)/2*3)$；假设 $g[5]-(5-1)/2*3<g[3]-(3-1)/2*3$，故窗口内 $f[3]$ 要继续保留，将 $c=5$ 入窗口 $q$ 队尾，$tail$ 更新为 $1$
  + $c = 7$：此时$head=0,tail=1$，窗口 $q=[3,5]$，即 $q[head] = q[0] = 3$，故 $f[7]$ 的转移会用到 $f[3]$：$f[7]=max(f[7], g[3]+(7-3)/2*3)$；假设 $g[5]-(5-1)/2*3<g[3]-(3-1)/2*3<g[7]-(7-1)/2*3$，故窗口内 $f[3],f[5]$ 都不需要继续保留，$tail$ 更新为 $-1$；最终，将 $c=7$ 入窗口 $q$ 队尾，$tail$ 更新为 $0$
  + $c = 9$：此时$head=tail=0$，窗口 $q$ 内 $q[head] = q[0] = 7$，故 $f[9]$ 的转移会用到 $f[7]$：$f[9]=max(f[9], g[7]+(9-7)/2*3)$；假设 $g[9]-(9-1)/2*3<g[7]-(7-1)/2*3$，故窗口内 $f[7]$ 要继续保留，将 $c=9$ 入窗口 $q$ 队尾，$tail$ 更新为 $1$

  ==疑惑：== $c=5$ 时，$f[3]$ 继续保留，就没必要将 $c=5$ 入窗口 $q$ 队尾，根本不会用到。

  ==**补充：**== 这些年，这种根据“取余”对状态做划分，然后转换为「滑动窗口」问题，配合某种数据结构（单调队列/哈希表）来实现优化的方式，早就出现在各种题目中了。

  例如 30. 串联所有单词的子串、1787. 使所有区间的异或结果为零 ... 

*****

###### 混合背包

「混合背包」是前三种传统「背包问题」的结合。先回顾一下三种传统「背包问题」：

- 「01 背包」：强调每件物品**「只能选择一次」**。对其进行「一维空间优化」并不能降低时间复杂度，进行「一维空间优化」时要求**「容量维度“从大到小”进行遍历」**。
- 「完全背包」：强调每件物品**「可以选择无限次」**。对其进行「一维空间优化」具有数学意义，可以将时间复杂度从 $\mathcal{O}(N*C*C)$ 降低到 $\mathcal{O}(N*C)$，进行「一维空间优化」时要求**「容量维度“从小到大”进行遍历」**。
- 「多重背包」：强调每件物品**「只能选择有限次」**。对其无论是进行「一维空间优化」还是「普通扁平化」都不能降低时间复杂度，要应用额外的优化手段：「二进制优化」或「单调队列优化」。

三种背包问题的**「难易程度」**是**「递增」**，但**「重要程度」**则是**「递减」** 的。

虽然「多重背包」的 「二进制优化」和「单调队列优化」都比较 trick。但其实「多重背包」并没有这么常见，以至于在 LeetCode 上都没找到与「多重背包」相关的题目。

==同时三种背包问题都有**「不超过」**和**「恰好」**两种状态定义。**这两种状态定义只在「初始化」上有区别。**==

至于该如何初始化则要抓住 **什么样的状态是合法的** ：

- 对于「不超过」的状态定义：

  $f[0][x]$ 均为合法值 $0$：代表不考虑任何物品，背包容量「不超过 $c$」所取得的最大价值为 $0$。

- 对于「恰好」的状态定义：

  $f[0][x]$ 中只有 $f[0][0]$ 为合法值 ，其他值均为“无效值”：代表不考虑任何物品，只有背包容量「恰好为 $0$」时所取得的最大价值为 $0$；其他容量「恰好为非 $0$」是无法取得有效价值的（因为不考虑任何物品）。

总的来说，三种背包问题都很经典（本质上都是组合优化问题），以至于「背包问题」直接成为了一类的动态规划模型。

混合背包其实就是综合了「01 背包」、「完全背包」和「多重背包」三种传统背包问题。

> 给定物品数量 $N$ 和背包容量 $C$。第 $i$ 件物品的体积是 $v[i]$，价值是 $w[i]$，可用数量为 $s[i]$：
>
> - 当 $s[i]$ 为 $-1$ 代表是该物品只能用一次
> - 当 $s[i]$ 为 $0$ 代表该物品可以使用无限次
> - 当 $s[i]$ 为任意正整数则代表可用 $s[i]$ 次
>
> 求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

在一维空间优化方式中「01 背包」将当前容量 $j$ 按照“从大到小”进行遍历，而「完全背包」则是将当前容量 $j$ 按照“从小到大”进行遍历。同时「多重背包」可以通过「二进制优化」彻底转移成「01 背包」。所以，只需要根据第 $i$ 个物品是「01 背包」物品还是「完全背包」物品，选择不同的遍历顺序即可。

```java
public int maxValue(int N, int C, int[] w, int[] v, int[] s) {
  // 构造出物品的「价值」和「体积」列表
  List<Integer> worth = new ArrayList<>();
  List<Integer> volume = new ArrayList<>();
  for (int i = 0; i < N; i++) {
    int type = s[i];

    // 多重背包：应用「二进制优化」转换为 0-1 背包问题
    if (type > 0) { 
      for (int k = 1; k <= type; k *= 2) {
        type -= k;
        worth.add(w[i] * k);
        volume.add(v[i] * k);
      }
      if (type > 0) {
        worth.add(w[i] * type);
        volume.add(v[i] * type);
      }

      // 01 背包：直接添加
    } else if (type == -1) {
      worth.add(w[i]);
      volume.add(v[i]);

      // 完全背包：对 worth 做翻转进行标记
    } else {
      worth.add(-w[i]);
      volume.add(v[i]);
    }
  }

  // 使用「一维空间优化」方式求解三种背包问题
  int[] dp = new int[C + 1];
  for (int i = 0; i < worth.size(); i++) {
    int wor = worth.get(i);
    int vol = volume.get(i);

    // 完全背包：容量「从小到大」进行遍历
    if (wor < 0) { 
      for (int j = vol; j <= C; j++) 
        // 同时记得将 worth 重新翻转为正整数
        dp[j] = Math.max(dp[j], dp[j - vol] - wor); 

      // 01 背包：包括「原本的 01 背包」和「经过二进制优化的完全背包」
      // 容量「从大到小」进行遍历
    } else { 
      for (int j = C; j >= vol; j--) 
        dp[j] = Math.max(dp[j], dp[j - vol] + wor);
    }
  }
  return dp[C];
}
```

********

###### 分组背包

> 给定 $N$ 个物品组，和容量为 $C$ 的背包。第 $i$ 个物品组共有 $S[i]$ 件物品，其中第 $i$ 组的第 $j$ 件物品的成本为 $v[i][j]$，价值为 $w[i][j]$。**每组有若干个物品，同一组内的物品最多只能选一个。**
>
> 求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。



###### 多维背包

###### 树形背包

###### 背包求方案数

###### 背包求具体方案

###### 泛化背包

******

##### 回文串

******

******

### 